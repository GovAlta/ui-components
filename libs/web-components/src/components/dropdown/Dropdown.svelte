<svelte:options customElement="goa-dropdown" />

<script lang="ts">
  import { onMount, tick } from "svelte";

  import type { GoAIconType } from "../icon/Icon.svelte";
  import type { Spacing } from "../../common/styling";
  import type { Option } from "./DropdownItem.svelte";
  import { dispatch, fromBoolean, receive, relay, toBoolean } from "../../common/utils";
  import { calculateMargin } from "../../common/styling";
  import { FieldsetResetErrorsMsg, FieldsetSetErrorMsg, FormFieldMountMsg, FormFieldMountRelayDetail, FormSetValueMsg, FormSetValueRelayDetail } from "../../types/relay-types";

  interface EventHandler {
    handleKeyUp: (e: KeyboardEvent) => void;
    handleKeyDown: (e: KeyboardEvent) => void;
  }

  // Props

  export let name: string;
  export let arialabel: string = "";
  export let arialabelledby: string = "";
  export let value: string | undefined = "";
  export let filterable: string = "false";
  export let leadingicon: GoAIconType | null = null;
  export let maxheight: string = "276px";
  export let placeholder: string = "";
  export let width: string = "";
  export let disabled: string = "false";
  export let error: string = "false";
  export let multiselect: string = "false";
  export let native: string = "false";
  export let relative: string = "false";
  export let mt: Spacing = null;
  export let mr: Spacing = null;
  export let mb: Spacing = null;
  export let ml: Spacing = null;
  export let testid: string = "";

  //
  // Private
  //

  let _options: Option[] = [];
  let _selectedOption: Option | undefined;
  let _isMenuVisible = false;
  let _highlightedIndex: number = -1;
  let _width: string;
  let _popoverMaxWidth: number;

  let _rootEl: HTMLElement;
  let _menuEl: HTMLElement;
  let _inputEl: HTMLInputElement;
  let _eventHandler: EventHandler;

  let _isDirty: boolean = false;
  let _filteredOptions: Option[] = [];
  let _values: string[] = [];

  let _bindTimeoutId: any;

  let _mountStatus: "active" | "ready" = "ready";
  let _mountTimeoutId: any = undefined;

  //
  // Reactive
  //

  $: _disabled = toBoolean(disabled);
  $: _error = toBoolean(error);
  $: _multiselect = toBoolean(multiselect);
  $: _native = toBoolean(native);
  $: _filterable = toBoolean(filterable) && !_native;

  // To keep track of active descendant for the accessibility
  $: _activeDescendantId = _filteredOptions[_highlightedIndex]
    ? _filteredOptions[_highlightedIndex].value
    : undefined;

  $: {
    _values = parseValues(value || "");
    setSelected();
  }

  //
  // Hooks
  //

  onMount(() => {
    getChildren();
    addRelayListener();
    sendMountedMessage();

    _eventHandler = _filterable
      ? new ComboboxKeyUpHandler(_inputEl)
      : new DropdownKeyUpHandler(_inputEl);
  });

  //
  // Functions
  //

  function addRelayListener() {
    receive(_rootEl, (action, data) => {
      switch (action) {
        case FormSetValueMsg:
          onSetValue(data as FormSetValueRelayDetail);
          break;
        case FieldsetSetErrorMsg:
          error = "true";
          break;
        case FieldsetResetErrorsMsg:
          error = "false";
          break;
      }
    });
  }

  function onSetValue(detail: FormSetValueRelayDetail) {
    value = detail.value
    dispatch(_rootEl, "_change", { name, value }, { bubbles: true });
  }

  function sendMountedMessage() {
    relay<FormFieldMountRelayDetail>(
      _rootEl,
      FormFieldMountMsg,
      { name, el: _rootEl},
      { bubbles: true, timeout: 10 },
    );
  }

  function getChildren() {
    _rootEl?.addEventListener("dropdown-item:mounted", (e: Event) => {

      const detail = (e as CustomEvent<Option>).detail;

      if (_mountStatus === "ready") {
        if (detail.mountType === "reset") {
          _options = [];
        }
        _mountStatus = "active";
      }

      switch (detail.mountType) {
        case "append":
          _options = [..._options, detail];
          break;
        case "prepend":
          _options = [detail, ..._options];
          break;
        case "reset":
          _options = [..._options, detail];
          break;
      }

      // reset the mountStatus back to `ready` after all new children are mounted
      if (_mountTimeoutId) {
        clearTimeout(_mountTimeoutId);
      }
      _mountTimeoutId = setTimeout(() => {
        _mountStatus = "ready";
        _mountTimeoutId = undefined;
      }, 10);

      // ensure bind only runs once for all children
      if (_bindTimeoutId) {
        clearTimeout(_bindTimeoutId);
      }
      _bindTimeoutId = setTimeout(bind, 1);
    });
  }

  function bind() {
    syncFilteredOptions();
    if (!width) {
      _width = getLongestChildWidth(_options);
    }
    if (_native) return;

    setSelected();

    if (width) {
      _width = width;
    }

    // This is only here to allow the tests to pass :(
    if (!width && _options.length > 0) {
      _width = getLongestChildWidth(_options);
    }
  }

  function setSelected() {
    _selectedOption = _options.find((o) => o.value == _values[0]);
  }

  // parse and convert values to strings to avoid later type comparison issues
  function parseValues(selectedValue: string) {
    let rawValue: string[];
    try {
      rawValue = JSON.parse(selectedValue || `[""]`);
    } catch (e) {
      rawValue = [selectedValue];
    }
    const rawValues = typeof rawValue === "object" ? rawValue : [rawValue];
    // convert all values to strings to avoid later type comparison issues
    return rawValues.map((val: unknown) => `${val}`);
  }

  // compute the required width to ensure all children fit
  function getLongestChildWidth(options: Option[]): string {
    // set width to longest item
    const optionsWidth = options
      .map((option: Option) => {
        const label = `${option.label}` || `${option.value}` || "";
        return label.length;
      })
      .sort((a: number, b: number) => (a > b ? 1 : -1))
      .pop();

    // longest one defines the width
    let maxWidth = Math.max(optionsWidth || 0, placeholder.length) + 8;

    // compensate for icon width
    if (leadingicon) {
      maxWidth += 2;
    }

    return `${maxWidth}ch`;
  }

  // Change the direction of highlighted options for Arrow up and down
  function changeHighlightedOption(offset: number) {
    let index = _highlightedIndex + offset;
    let items = !_filteredOptions?.length ? _options : _filteredOptions;
    if (items.length === 0) return;

    // if index is out of scope
    if (index < 0) {
      index = _filterable ? items.length - 1 : 0;
    } else if (index >= items.length) {
      index = _filterable ? 0 : items.length - 1;
    }
    _highlightedIndex = index;
    scrollToOption(index);
  }

  function scrollToOption(index: number) {
    const liNode = _menuEl.querySelector(
      `li[data-index="${index}"]`,
    ) as HTMLLIElement;
    if (!liNode) return;

    const liOptionRect = liNode.getBoundingClientRect();
    const ulRect = _menuEl.getBoundingClientRect();
    const isInView =
      liOptionRect.top >= 0 &&
      liOptionRect.left >= 0 &&
      liOptionRect.bottom <= ulRect.height &&
      liOptionRect.right <= ulRect.width;

    if (isInView) return;

    liNode.scrollIntoView({ behavior: "smooth", block: "nearest" });
  }

  function syncFilteredOptions() {
    _filteredOptions = _filterable
      ? _options.filter((option) => isFilterMatch(option, _inputEl?.value || ""))
      : _options;
  }

  function showMenu() {
    if (_disabled) {
      return;
    }

    setTimeout(async () => {
      syncFilteredOptions();
      _isMenuVisible = true;
      // _inputEl?.focus();
    }, 0);
  }

  function hideMenu() {
    _isMenuVisible = false;
  }

  function isFilterMatch(option: Option, filter: string) {
    // empty string matches all
    if (filter.length === 0) return true;

    let value = option.filter || option.label || option.value;
    value = value.toLowerCase();
    filter = filter.toLowerCase().trim();

    return value.startsWith(filter) || value.includes(" " + filter);
  }

  // update the value show to the user in the <input> element
  function setDisplayedValue() {
    _inputEl.value = _selectedOption?.label || _selectedOption?.value || "";
  }

  function dispatchValue(newValue?: string) {
    const detail = _multiselect
      ? { name, values: [newValue, ..._values] }
      : { name, value: newValue };

    if (!_isDirty) {
      return;
    }

    setTimeout(() => {
      _rootEl?.dispatchEvent(
        new CustomEvent("_change", { composed: true, detail, bubbles: true }),
      );
      _isDirty = false;
    }, 1);
  }

  //
  // Event handlers
  //

  function onSelect(option: Option) {
    if (_disabled) return;

    _isDirty = option.value !== _selectedOption?.value;
    _selectedOption = option;

    if (!_native) {
      hideMenu();
      syncFilteredOptions();
      setDisplayedValue();
    }
    dispatchValue(option.value);
  }

  // Fires when on blur and changes have been made AND when the browser auto-fill is performed
  async function onChange(_e: Event) {
    if (!_filterable) return;

    await tick();
    syncFilteredOptions();

    if (_filteredOptions.length === 1) {
      const option = _filteredOptions[0];
      _selectedOption = option;
      dispatchValue(option.value);
      setDisplayedValue();
      setTimeout(() => {
        hideMenu();
      }, 10);

    } else {
      _selectedOption = undefined;
      setDisplayedValue();
      dispatchValue("");
    }
  }

  function onInputKeyUp(e: KeyboardEvent) {
    if (_disabled) return;
    _isDirty = true
    _eventHandler.handleKeyUp(e);
  }

  function onInputKeyDown(e: KeyboardEvent) {
    if (_disabled) return;
    _isDirty = true
    _eventHandler.handleKeyDown(e);
  }

  function onClearIconKeyDown(e: KeyboardEvent) {
    if (e.key === "Enter" || e.key === " ") {
      e.stopPropagation();
      reset();
      showMenu();
    }
  }

  function onClearIconClick(e: Event) {
    reset();
    showMenu();
    e.stopPropagation();
  }

  function onNativeSelect(e: Event) {
    const target = e.currentTarget as HTMLSelectElement;
    const option = _options[target.selectedIndex];
    _isDirty = true;
    onSelect(option);
  }

  function reset() {
    if (_disabled) return;

    _activeDescendantId = undefined;
    _highlightedIndex = -1;
    _selectedOption = undefined;
    _isDirty = true;

    syncFilteredOptions();
    dispatchValue("");
    setDisplayedValue();
  }

  async function onChevronClick(e: Event) {
    await tick();
    showMenu();
    e.stopPropagation();
  }

  class ComboboxKeyUpHandler implements EventHandler {
    constructor(private input: HTMLInputElement) { }

    onEscape(_e: KeyboardEvent) {
      reset();
      // FIXME: on escape should allow the next tab click to move to the next element, currently
      // clicking tab after esc will refocus onto the Dropdown

      // _inputEl.focus();
      // e.preventDefault();
      // e.stopPropagation();
    }

    onEnter(e: KeyboardEvent) {
      const option = _filteredOptions[_highlightedIndex];
      if (option) {
        _isDirty = option.value !== _selectedOption?.value;
        onSelect(option);
      }

      if (_selectedOption) {
        hideMenu();
      } else {
        showMenu();
      }

      e.stopPropagation();
    }

    onArrow(e: KeyboardEvent, direction: "up" | "down") {
      if (!_isMenuVisible) showMenu();

      changeHighlightedOption(direction === "up" ? -1 : 1);
      e.stopPropagation();
    }

    onTab(_: KeyboardEvent) {
      const matchedOption = _filteredOptions.find(
        (option) =>
          option.label?.toLowerCase() === this.input.value.toLowerCase(),
      );

      if (matchedOption) {
        onSelect(matchedOption);
      }

      hideMenu();
    }

    onKeyUp(_: KeyboardEvent) {
      showMenu();
    }

    handleKeyUp(e: KeyboardEvent) {
      switch (e.key) {
        case "Enter":
          this.onEnter(e);
          break;
        case "ArrowUp":
          this.onArrow(e, "up");
          break;
        case "ArrowDown":
          this.onArrow(e, "down");
          break;
        case "Home":
          this.input.setSelectionRange(0, 0);
          break;
        case "End":
          this.input.setSelectionRange(
            this.input.value.length,
            this.input.value.length,
          );
          break;
        case "Tab":
          // ignore tab
          break;
        default:
          this.onKeyUp(e);
          break;
      }
    }

    handleKeyDown(e: KeyboardEvent) {
      switch (e.key) {
        case "Escape":
          this.onEscape(e);
          break;
        case "Tab":
          this.onTab(e);
          break;
      }
    }
  }

  class DropdownKeyUpHandler implements EventHandler {
    constructor(_input: HTMLInputElement) {}

    onEnter(e: KeyboardEvent) {
      if (_isMenuVisible) {
        const option = _filteredOptions[_highlightedIndex];
        if (option) {
          onSelect(option);
        }
        hideMenu();
      } else {
        showMenu();
      }

      e.preventDefault();
      e.stopPropagation();
    }

    onArrow(e: KeyboardEvent, direction: "up" | "down") {
      if (!_isMenuVisible) showMenu();
      changeHighlightedOption(direction === "up" ? -1 : 1);
      e.preventDefault();
      e.stopPropagation();
    }

    handleKeyDown(e: KeyboardEvent) {
      switch (e.key) {
        case " ":
        case "Enter":
          this.onEnter(e);
          break;
        case "ArrowUp":
          this.onArrow(e, "up");
          break;
        case "ArrowDown":
          this.onArrow(e, "down");
          break;
        case "Tab":
          hideMenu();
          break;
      }

      return false;
    }

    handleKeyUp(e: KeyboardEvent) {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
        case " ":
        case "Enter":
          e.preventDefault();
          e.stopPropagation();
      }
    }
  }
</script>

<!-- Template -->
<div
  data-testid={testid || `${name}-dropdown`}
  class="dropdown"
  class:dropdown-native={_native}
  style={`
      ${calculateMargin(mt, mr, mb, ml)};
      --width: ${_width};
    `}
  bind:this={_rootEl}
  bind:clientWidth={_popoverMaxWidth}
>
  {#if _native}
    <select
      {name}
      aria-label={arialabel || name}
      aria-labelledby={arialabelledby}
      class:error={_error}
      disabled={_disabled}
      id={name}
      on:change={onNativeSelect}
    >
      <slot />
      {#each _options as option}
        <option selected={value === option.value} value={option.value}>
          {option.label}
        </option>
      {/each}
    </select>
  {:else}
    <slot />
    <!-- list and filter -->
    <goa-popover
      {disabled}
      {relative}
      data-testid="option-list"
      width={`${_popoverMaxWidth || 100}px`}
      open={_isMenuVisible}
      padded="false"
      tabindex="-1"
      on:_open={showMenu}
      on:_close={hideMenu}
    >
      <div
        slot="target"
        class="dropdown-input-group"
        class:dropdown-input-group--disabled={_disabled}
        class:error={_error}
      >
        {#if leadingicon}
          <goa-icon
            class="dropdown-input--leading-icon"
            data-testid="leading-icon"
            type={leadingicon}
          />
        {/if}

        <input
          style={`
            cursor: ${!_disabled ? (_filterable ? "auto" : "pointer") : "default"};
          `}
          data-testid="input"
          bind:this={_inputEl}
          value={_selectedOption?.label || _selectedOption?.value || ""}
          type="text"
          role="combobox"
          autocomplete="off"
          aria-autocomplete="list"
          aria-controls={`menu-${name}`}
          aria-expanded={_isMenuVisible}
          aria-label={arialabel || name}
          aria-labelledby={arialabelledby}
          id={name}
          aria-activedescendant={_activeDescendantId}
          aria-disabled={_disabled}
          aria-owns={_isMenuVisible ? `menu-${name}` : undefined}
          aria-haspopup="listbox"
          disabled={_disabled}
          readonly={!_filterable}
          {placeholder}
          {name}
          on:keydown={onInputKeyDown}
          on:keyup={onInputKeyUp}
          on:change={onChange}
        />

        {#if _inputEl?.value && _filterable}
          <goa-icon
            id={name}
            data-testid="clear-icon"
            tabindex={_disabled ? -1 : 0}
            role="button"
            arialabel={`clear ${arialabel || name}`}
            ariacontrols={`menu-${name}`}
            ariaexpanded={fromBoolean(_isMenuVisible)}
            on:click={onClearIconClick}
            on:keydown={onClearIconKeyDown}
            class="dropdown-icon--clear"
            class:disabled={_disabled}
            size="medium"
            type="close"
          />
        {:else}
          <!-- svelte-ignore a11y-click-events-have-key-events -->
          <goa-icon
            role="button"
            tabindex="0"
            id={name}
            arialabel={arialabel || name}
            ariacontrols={`menu-${name}`}
            ariaexpanded={fromBoolean(_isMenuVisible)}
            class="dropdown-icon--arrow"
            size="medium"
            type={_isMenuVisible ? "chevron-up" : "chevron-down"}
            on:click={onChevronClick}
          />
        {/if}
      </div>

      <!--Menu-->
      <ul
        id={`menu-${name}`}
        role="listbox"
        tabindex="-1"
        data-testid="dropdown-menu"
        bind:this={_menuEl}
        aria-label={arialabel || name}
        aria-labelledby={arialabelledby}
        style={`
            outline: none;
            overflow-y: auto;
            max-height: ${maxheight};
          `}
      >
        {#each _filteredOptions as option, index (index)}
          <!-- svelte-ignore a11y-click-events-have-key-events -->
          <li
            id={option.value}
            aria-selected={_selectedOption?.value ===
              (option.label || option.value)}
            class:selected={_selectedOption?.value ===
              (option.label || option.value)}
            class="dropdown-item"
            class:dropdown-item--highlighted={index === _highlightedIndex}
            data-index={index}
            data-testid={`dropdown-item-${option.value}`}
            data-value={option.value}
            role="option"
            style="display: block"
            on:click={() => {
              _isDirty = true;
              onSelect(option);
            }}
          >
            {option.label || option.value}
          </li>
        {:else}
          {#if _filterable}
            <li class="dropdown-item" data-testid="dropdown-item-not-found">
              No matches found
            </li>
          {/if}
        {/each}
      </ul>
    </goa-popover>
  {/if}
</div>

<style>
  :host {
    box-sizing: border-box;
    font-family: var(--goa-font-family-sans);
  }

  .dropdown {
    cursor: pointer;
    width: var(--width, 100%);
  }
  @media (--mobile) {
    .dropdown {
      width: 100%;
    }
  }
  @media (--not-mobile) {
    .dropdown {
      width: var(--width, 100%);
    }
  }

  .dropdown-input-group {
    box-sizing: border-box;
    outline: none;
    transition: box-shadow 0.1s ease-in;
    border: 1px solid var(--goa-color-greyscale-700);
    border-radius: var(--goa-border-radius-m);
    display: inline-flex;
    align-items: stretch;

    /* The vertical align fixes inputs with a leading icon to not be vertically offset */
    vertical-align: middle;
    background-color: var(--goa-color-greyscale-white);
    cursor: pointer;
    /*width of dropdown input should be 100% based on its parent div*/
    width: 100%;
  }
  .dropdown-input-group:hover {
    border-color: var(--goa-color-interactive-hover);
  }
  .dropdown-input-group:has(input:focus-visible) {
    box-shadow: 0 0 0 3px var(--goa-color-interactive-focus);
  }
  .dropdown-input-group.error,
  .dropdown-input-group.error:hover {
    border: 2px solid var(--goa-color-interactive-error);
    box-shadow: 0 0 0 1px var(--goa-color-interactive-error);
  }
  .dropdown-input-group.error:has(:focus-visible) {
    border: 2px solid var(--goa-color-interactive-error);
    box-shadow: 0 0 0 3px var(--goa-color-interactive-focus);
  }
  @container not (--mobile) {
    .dropdown-input-group {
      width: var(--width);
    }
  }

  .dropdown-icon--arrow,
  .dropdown-icon--clear {
    margin-right: var(--goa-space-s);
  }

  /* TODO: add indicator to when the reset button has focus state */
  .dropdown-icon--clear:focus:not(.disabled),
  .dropdown-icon--clear:active:not(.disabled) {
    outline: none;
  }

  .dropdown-input--leading-icon {
    margin-left: 0.75rem;
  }

  .dropdown-input--leading-icon + input {
    padding-left: 0.5rem;
  }

  input {
    display: inline-block;
    color: var(--goa-color-text-default);
    font-size: var(--goa-font-size-4);
    padding: var(--goa-space-xs);
    padding-left: var(--goa-space-s);
    line-height: calc(40px - calc(var(--goa-space-xs) * 2));
    background-color: transparent;
    width: 100%;
    flex: 1 1 auto;
    font-family: var(--goa-font-family-sans);
    z-index: 1;
  }

  input,
  input:focus,
  input:hover,
  input:active {
    outline: none;
    border: none;
  }

  input[aria-disabled="true"] {
    color: var(--goa-color-text-secondary);
  }

  .dropdown-input-group--disabled,
  .dropdown-input-group--disabled:hover,
  .dropdown-input-group--disabled:active,
  .dropdown-input-group--disabled:focus {
    background-color: var(--goa-color-greyscale-100);
    border-color: var(--goa-color-greyscale-200) !important;
    cursor: default;
    box-shadow: none !important;
  }

  /** menu **/
  ul[role="listbox"] {
    border-radius: var(--goa-border-radius-m);
    padding: 0;
    margin: 0;
  }

  /* dropdown items */

  .dropdown-item {
    margin: 0;
    padding: 0.5rem;
    cursor: pointer;
    color: var(--goa-color-greyscale-black);

    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .dropdown-item:hover,
  .dropdown-item--highlighted {
    background: var(--goa-color-greyscale-100);
    color: var(--goa-color-interactive-hover);
  }

  .dropdown-item[aria-selected="true"] {
    background: var(--goa-color-interactive-default);
    color: var(--goa-color-greyscale-white);
  }

  .dropdown-item[aria-selected="true"]:hover,
  .dropdown-item[aria-selected="true"].dropdown-item--highlighted {
    background: var(--goa-color-interactive-hover);
    color: var(--goa-color-greyscale-white);
  }

  /* Native styling  */
  .dropdown-native {
    position: relative;
    border: 1px solid var(--goa-color-greyscale-700);
    border-radius: var(--goa-border-radius-m);
    background-color: var(--goa-color-greyscale-white);
    transition: box-shadow 0.1s ease-in;
  }

  .dropdown-native:has(select:disabled) {
    background-color: var(--goa-color-greyscale-100);
    border-color: var(--goa-color-greyscale-200);
    box-shadow: none;
    color: var(--goa-color-text-secondary);
    cursor: default;
  }

  .dropdown-native:has(select.error) {
    border: 2px solid var(--goa-color-interactive-error);
  }

  .dropdown-native:hover {
    border-color: var(--goa-color-interactive-hover);
  }

  select {
    border: none;
    font: var(--goa-font-family-sans);
    background-color: transparent;
    color: var(--goa-color-text-default);
    font-size: var(--goa-font-size-4);
    appearance: none;
    padding: calc(var(--goa-space-xs) + 1px);
    padding-left: var(--goa-space-s);
    padding-right: 3rem;
    outline: none;
    width: 100%;
  }

  .dropdown-native::after {
    content: "";
    position: absolute;
    right: 0.6rem;
    top: 0.6rem;
    pointer-events: none;
    width: 1.5rem;
    height: 1.5rem;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><path fill='none' stroke='%23333333' stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M112 184l144 144 144-144' /%3E%3C/svg%3E");
    background-repeat: none;
  }

  .dropdown-native:has(:focus-visible) {
    box-shadow: 0 0 0 3px var(--goa-color-interactive-focus);
  }

  goa-icon:focus-visible {
    outline: none;
  }
</style>
